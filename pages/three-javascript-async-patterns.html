<!DOCTYPE html><html><head><title>Three Javascript Async Patterns</title><meta name="viewport" content="width=device-width,initial-scale=1"><link href="/styles/article.css" rel="stylesheet"><link href="/styles/hljs.css" rel="stylesheet"><link href="/styles/main.css" rel="stylesheet"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-91252031-1', 'auto');
ga('send', 'pageview');</script></head><body><header><h1 id="steve-konves">Steve Konves</h1></header><section id="main"><article><h1 id="three-javascript-async-patterns">Three Javascript Async Patterns</h1><p>Node makes heavy use of asynchronous, non-blocking program flow. As you know, by default, Javascript is single-threaded (although there are ways around this with web workers or other methods of spawning child processes); however, in most cases, the best practice is to embrace this limitation and make use of one of the many patterns for writing asynchronous code. This post isn&#39;t about the <em>why</em> to write non-blocking code, but rather <em>how</em>.</p><p>The three patterns discussed here are callbacks, promises, and async/await. There are other patterns as well as multiple variations of each so this post might expand in the future.</p><h2 id="examples">Examples</h2><p>Here is an example of the same action written in each pattern:</p><p>Callbacks:</p><pre class="hljs"><code>doThing(<span class="hljs-string">'value'</span>, (err, result) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-comment">// handle error here</span>
        <span class="hljs-built_in">console</span>.error(err);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// handle success here</span>
        <span class="hljs-built_in">console</span>.log(result);
    }
});</code></pre><p>Promises:</p><pre class="hljs"><code>doThing(<span class="hljs-string">'value'</span>)
    .then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
        <span class="hljs-comment">// handle success here</span>
        <span class="hljs-built_in">console</span>.log(value);
    })
    .catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> {
        <span class="hljs-comment">// handle error here</span>
        <span class="hljs-built_in">console</span>.error(reason);
    });</code></pre><p>Async/await:</p><pre class="hljs"><code><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> doThing(<span class="hljs-string">'value'</span>);
    <span class="hljs-comment">// handle success here</span>
    <span class="hljs-built_in">console</span>.log(result);
} <span class="hljs-keyword">catch</span> (ex) {
    <span class="hljs-comment">// handle error here</span>
    <span class="hljs-built_in">console</span>.error(ex);
}</code></pre><p>Let&#39;s break down each of these patterns.</p><h2 id="callbacks">Callbacks</h2><p>A callback is nothing more than a function passed as a parameter to another function. This function is then called whenever an asynchronous operation has completed. The body of the callback contains code that is intended to execute after the asynchronous operation. Because they are simply functions passed as parameters, callbacks are heavily dependent on convention, the most common of which is the &quot;error-first&quot; callback passed as the final parameter. By virtue of its name, an error-first callback is a function that takes an error object as its first parameter (or a falsey value if no error was encountered) and then any return values as subsequent parameters.</p><h3 id="the-good">The Good</h3><p>Callbacks are a language-level feature. The Javascript language defines functions as objects that, among other things, can be passed around as parameters. Because of this, callbacks are supported in every platform/environment/engine without the need for additional packages or transpiling. A callback can be expected to work the same server-side in Node (V8) as it does client-side in the Edge browser (Chakra).</p><h3 id="the-bad">The Bad</h3><p>Two words: callback hell. All code after an asynchronous operation is nested inside a function or lambda. More operations means more indentation which quickly eats away at recommended max line widths and makes code much less readable. The problem becomes more pronounced with larger functions; therefore, the best way to avoid these &quot;pyramids of death&quot; is to keep functions small (which is a good thing anyway).</p><h3 id="the-verdict">The Verdict</h3><p>Aside from the way the code <em>looks</em>, callbacks are the simplest, most portable pattern. Use them when you are working within environments where you want to keep code small by not adding added libraries or don&#39;t have access to a transpile such as Babel.</p><h2 id="promises">Promises</h2><p>Promises are framework-level features. While there is a default promise implementation that exists all modern Javascript environments, they are still an executed code artifact rather than native Javascript syntax.</p><h3 id="the-good">The Good</h3><p>Their framework-level status is an asset. They provide for a broader range functionality than just asynchronously returning a value or an error, for example <code>Promise.all()</code> allows for multiple operations to be run in parallel rather than just asynchronously. Promises also provide an alternate code structure. Multiple promises can be chained to facilitate multiple asynchronous operations without forcing a new level of indentation after each. This syntax can lead to more readable code. Aside from the default promise implementation in Node, there are a number of other promise libraries available that even allow for standard callback-based functions to be &quot;promisified.&quot;</p><h3 id="the-bad">The Bad</h3><p>Their framework-level status is a liability. Because of this, there is always an overhead cost in both time and memory usage when using promises instead of callbacks. <a href="https://www.npmjs.com/package/bluebird">Bluebird</a> is one of the most performant promise libraries, yet still incurs overhead cost, albeit slightly. They publish <a href="https://github.com/petkaantonov/bluebird/tree/master/benchmark">benchmarks</a> of how they stack up against the competition, including baseline callbacks.</p><p>Another liability is that, as code rather than as syntax, users are free to implement Promise libraries that operates in any particular way. And as Murphy&#39;s Law states, anything that can happen will be implemented independently in 32 different npm packages. In my opinion, while a diversity in options is often nice, in the case of promises, it is a barrier to adoption. In addition to the differences between libraries, the general concept of &quot;resolving&quot; and &quot;rejecting&quot; values is not nearly as intuitive as passing a function that will be called later. In short, while promises offer more functionality than callbacks, they do so at the cost of being initially harder to learn and use.</p><h3 id="the-verdict">The Verdict</h3><p>My personal preference when presented a choice between language- and framework-level features that are reasonably similar is to choose the language-level feature. There are cases (eg, parallelism) where promises offer a large reduction in code and are thus the obvious choice. In any general case, I find myself using callbacks; in more complex cases I use <code>Promise.all()</code>, <code>Promise.one()</code>, or other promise functionality.</p><h2 id="async-await">Async/Await</h2><p>Async/await borrows from other &quot;real&quot; languages and facilitates executing asynchronous code with synchronous-looking syntax. Consider the following example:</p><pre class="hljs"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">inputValue</span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> a = <span class="hljs-keyword">await</span> asyncFunc1(<span class="hljs-string">'value'</span>);
        <span class="hljs-keyword">const</span> b = <span class="hljs-keyword">await</span> asyncFunc2(a);
        <span class="hljs-keyword">const</span> c = syncFunc3(b);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncFunc4(c);
    } <span class="hljs-keyword">catch</span> (ex) {
        <span class="hljs-comment">// handle exception</span>
    }
}</code></pre><p>It is obvious that functions 1, 2, and 4 are asynchronous, but the developer doesn&#39;t have to waste brain cycles mentally parsing this equivalent, callback-based code:</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">inputValue</span>) </span>{
    asyncFunc1(<span class="hljs-string">'value'</span>, (err, a) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-comment">// handle error</span>
        } <span class="hljs-keyword">else</span> {
            asyncFunc2(<span class="hljs-string">'value'</span>, (err, b) =&gt; {
                <span class="hljs-keyword">if</span> (err) {
                    <span class="hljs-comment">// handle error</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-keyword">const</span> c = syncFunc3(b);
                        asyncFunc4(<span class="hljs-string">'value'</span>, (err, d) =&gt; {
                            <span class="hljs-keyword">if</span> (err) {
                                <span class="hljs-comment">// handle error</span>
                            } <span class="hljs-keyword">else</span> {
                                callback(<span class="hljs-literal">null</span>, d);
                            }
                        });
                    } <span class="hljs-keyword">catch</span> (ex) {
                        <span class="hljs-comment">// handle error</span>
                    }                    
                }
            });
        }
    });
}</code></pre><h3 id="the-good">The Good</h3><p>Similar to callbacks, it is a language- rather than framework-level feature and allows for the use of other common language features such as try/catch. When awaiting a promise, rejections are thrown as errors which can then be caught in the same way as in synchronous code. In doing so, they also allow for simpler, more synchronous-looking code than both callbacks and promises (as shown in the example above). Under the hood, they are just a new way of calling promises: an &quot;async&quot; function is actually a function that returns a promise. This means that you can call <code>.then()</code> on async functions and <code>await</code> promises.</p><h3 id="the-bad">The Bad</h3><p>Using async/await requires the use of a transpiler such as Babel. Setting up such an environment can be a pain and the overhead effort to do it right can often be a sufficient barrier to entry. Currently, this pattern is just syntactic sugar over the default promise code; as with all ES-next code, the &quot;real&quot; version that our future selves get to work with could theoretically be subtly different (or never be implemented at all). Lastly, it is a much less common pattern when compared to callbacks and promises and will thus be less familiar to most developers.</p><h3 id="the-verdict">The Verdict</h3><p>If you have access to an environment with the necessary transpiler tooling, use async/await. It allows for asynchronous code to be written in a very clear, language-level syntax. Aside from setting up transpilation, there is much less intellectual overhead in grokking async/await compared to promises.</p><h2 id="my-conclusion">My Conclusion</h2><p>From a purely syntactical perspective, I find async/await to exceed the strengths of both callbacks and promises. It is a language-level feature, asynchronicity is obvious, error handling is natural, the syntax precludes the callback pyramid of death, and it plays nicely with existing promise patterns. The only real downside is the need to transpile. For personal projects, I have solved that problem by creating a <a href="https://github.com/skonves/esnext-reference">reference project</a> wherein I have already <del>wasted</del> invested all of the necessary hours to get Babel setup. Feel free to check that out and modify it for your needs.</p><p>I am considering doing a more in-depth write up on async/await in the future.</p></article><nav><div id="navtop"><h1 id="articles">Articles</h1></div><ul><li><a href="/pages/three-javascript-async-patterns.html">Three Javascript Async Patterns</a></li><li><a href="/pages/correlation-ids.html">Correlation IDs in Practice</a></li></ul><div id="navbottom"><h1 id="about-this-blog">About this blog</h1><p>Steve Konves is a software developer in the Phoenix area. This content is my own and doesn&#39;t necessarily reflect the views of my employer. If you find a typo or want to suggest a fix, feel free to submit a pull request.</p></div></nav></section><footer><p>Made with <a href="https://github.com/skonves/interblag">interblag</a> by Steve Konves</p></footer></body></html>